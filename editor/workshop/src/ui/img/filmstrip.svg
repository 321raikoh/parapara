<svg xmlns="http://www.w3.org/2000/svg" height="100%" width="100%" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 140 132"
 preserveAspectRatio="xMinYMid meet">
 <defs>
   <style type="text/css">
    .plus-button-back, .close-button-back {
      fill: url(#button-grad);
      stroke: #483112;
      filter: url(#button-shadow);
    }
    /* 
     * Turn off the shadow at small screen sizes since you're not going to see
     * it.
     */
    @media screen and (max-height: 120px) {
      .plus-button-back, .close-button-back {
        filter: none;
      }
    }
    .plus-button-back {
      stroke-width: 2;
    }
    .close-button-back {
      stroke-width: 1;
    }
    .film-line {
     stroke: #FFFEFE;
     stroke-linecap: round;
     stroke-width: 12;
     stroke-dasharray: 4,24;
     stroke-dashoffset: 15;
    }
   </style>
   <!-- Gradients -->
   <linearGradient id="button-grad" x1="0" x2="0" y1="0" y2="1">
    <stop stop-color="#483112" offset="0"/>
    <stop stop-color="#0E0701" offset="1"/>
   </linearGradient>
   <!-- Filters -->
   <filter id="button-shadow" x="-20%" width="140%">
    <feGaussianBlur in="SourceAlpha" stdDeviation="1" result="blur"/>
    <feOffset in="blur" dx="1.5" dy="1.5" result="offsetBlur"/>
    <feFlood flood-color="#A6956E" result="colour"/>
    <feComposite in="colour" in2="offsetBlur" operator="in"/>
    <feBlend in="SourceGraphic" mode="normal"/>
   </filter>
   <!-- Frame bg -->
   <rect x="5" y="20" width="130" height="92" rx="26" fill="white"
    id="frame-bg"/>
   <!-- Frame mask -->
   <clipPath id="frame-mask">
    <rect x="5" y="20" width="130" height="92" rx="26"/>
   </clipPath>
   <!-- Close button -->
   <g id="close-button">
    <rect x="93" y="28" width="31" height="31" rx="8"
      class="close-button-back"/>
    <g fill="white">
      <rect x="106" y="34.5" width="5" height="18" rx="3"
       transform="rotate(45 108.5 43.5)"/>
      <rect x="106" y="34.5" width="5" height="18" rx="3"
       transform="rotate(-45 108.5 43.5)"/>
    </g>
   </g>
 </defs>
 <!-- Backing -->
 <rect width="140" height="132" fill="#2E220E" id="backing"/>
 <!-- Dotted lines -->
 <g class="film-line">
  <line x1="140" y1="10" x2="0" y2="10" id="top-line"/>
  <line x1="140" y1="122" x2="0" y2="122" id="bottom-line"/>
 </g>
 <!-- The frames will be added here, in order from earlier to later -->
 <g id="frame-container"/>
 <!-- Plus frame -->
 <g id="plus-frame">
   <use xlink:href="#frame-bg"/>
   <rect x="36" y="36" width="60" height="60" rx="15" class="plus-button-back"/>
   <g fill="white">
    <rect x="62" y="50" width="8" height="32" rx="5"/>
    <rect x="50" y="62" width="32" height="8" rx="5"/>
   </g>
 </g>
 <script type="text/javascript">
 <![CDATA[
  const SVG_NS   = 'http://www.w3.org/2000/svg';
  const XLINK_NS = 'http://www.w3.org/1999/xlink';
  const ADD_FRAME_ANIM_DUR_MS = 1000;

  // We generate a lot of animations dynamically. To make sure they stay in sync
  // we record the current time when we start an action and use that as the
  // start time for all animations generated by that action.
  var animStartTime = null;

  document.updateFrame = function(svg, copy /*= true*/) {
    // If copy is true or undefined, clone the svg, otherwise adopt it
    // Find the current frame and replace the subtree with the
    //   copied/adopted svg
  }

  function addFrame() {
    animStartTime = document.documentElement.getCurrentTime();

    // XXX Stop any scrolling

    // Add content
    var container = document.getElementById('frame-container');

    // Add frame group
    var frame_g = document.createElementNS(SVG_NS, 'g');

    // Get position of plus frame
    var plusFrame = document.getElementById('plus-frame');
    var plusFrameTransform = plusFrame.transform.baseVal.consolidate();
    if (plusFrameTransform) {
      var xPos = plusFrameTransform.matrix.e;
      var yPos = plusFrameTransform.matrix.f;
      frame_g.setAttribute('transform', 'translate(' + xPos + ',' + yPos + ')');
    }

    // Add background
    var bg = document.createElementNS(SVG_NS, 'use');
    bg.setAttributeNS(XLINK_NS, 'xlink:href', '#frame-bg');
    frame_g.appendChild(bg);

    // Add group for content
    var content_g = document.createElementNS(SVG_NS, 'g');
    content_g.setAttribute('clip-path', 'url(#frame-mask)');
    frame_g.appendChild(content_g);

    // Add close button
    var close = document.createElementNS(SVG_NS, 'use');
    close.setAttributeNS(XLINK_NS, 'xlink:href', '#close-button');
    frame_g.appendChild(close);
    container.appendChild(frame_g);
    // XXX Add handler here
    // XXX Add handler for selection too

    // Animate the frame so it appears to grow
    var anim = document.createElementNS(SVG_NS, "animateTransform");
    anim.setAttribute("attributeName", "transform");
    anim.setAttribute("type", "scale");
    anim.setAttribute("from", "0 1");
    anim.setAttribute("to", "1 1");
    anim.setAttribute("dur", ADD_FRAME_ANIM_DUR_MS + "ms");
    anim.setAttribute("begin", animStartTime + "ms");
    anim.setAttribute("fill", "freeze");
    anim.addEventListener("end", selfDestruct);
    frame_g.appendChild(anim);

    // Extend backing rect and lines
    var backingRect = document.getElementById('backing');
    animLength(backingRect, backingRect.width, "width", 140);
    var topLine = document.getElementById('top-line');
    animLength(topLine, topLine.x1, "x1", 140);
    var bottomLine = document.getElementById('bottom-line');
    animLength(bottomLine, bottomLine.x1, "x1", 140);

    // Move the plus button along
    animTranslate(plusFrame, 140, 0);

    // XXX If that's going to push the + button so that any part of it is past
    //      window.innerWidth At animate documentElement.currentTranslate.x
    //      (using script :( ) so that the right edge of the + button frame ends
    //      up at window.innerWidth
    // XXX At the end of the animation, call selectFrame?? but don't scroll,
    //     just apply whatever effect we use to mark a frame as current
    // XXX Update our reference to the selected frame??? Do we need this?
  }

  function animTranslate(elem, x, y) {
    var list = elem.transform.baseVal;
    console.assert(list.length <= 1, "Unexpected transform list");

    // Work out from value and update transform too
    var from = [0,0];
    if (list.length) {
      var transform = list.getItem(0);
      console.assert(transform.type === SVGTransform.SVG_TRANSFORM_TRANSLATE,
                     "Unexpected transform list");
      from[0] = transform.matrix.e;
      from[1] = transform.matrix.f;
      transform.setTranslate(transform.matrix.e + x, transform.matrix.f + y);
    } else {
      var transform = document.documentElement.createSVGTransform();
      transform.setTranslate(x, y);
      list.appendItem(transform);
    }
    var to = [from[0]+x,from[1]+y];

    // Create anim
    var anim = document.createElementNS(SVG_NS, "animateTransform");
    anim.setAttribute("attributeName", "transform");
    anim.setAttribute("type", "translate");
    anim.setAttribute("from", from.join(" "));
    anim.setAttribute("to", to.join(" "));
    anim.setAttribute("dur", ADD_FRAME_ANIM_DUR_MS + "ms");
    anim.setAttribute("begin", animStartTime + "ms");
    anim.setAttribute("fill", "freeze");
    anim.addEventListener("end", selfDestruct);
    elem.appendChild(anim);
  }

  function animLength(elem, length, attrName, by) {
    var from = length.baseVal.value;
    var to = from + by;
    length.baseVal.value = to;
    addAnim(elem, attrName, { from: from, to: to });
  }

  function addAnim(elem, attr, params) {
    var anim = document.createElementNS(SVG_NS, "animate");
    anim.setAttribute("dur", ADD_FRAME_ANIM_DUR_MS + "ms");
    anim.setAttribute("attributeName", attr);
    anim.setAttribute("from", params.from);
    anim.setAttribute("to", params.to);
    anim.setAttribute("begin", animStartTime + "ms");
    anim.setAttribute("fill", "freeze");
    // XXX Add fallback for browsers that don't do TimeEvents
    anim.addEventListener("end", selfDestruct);
    elem.appendChild(anim);
  }

  // Function to be called when an animation ends so it can be destroyed
  function selfDestruct(evt) {
    var parent = evt.target.parentNode;
    if (!parent)
      return;

    parent.removeChild(evt.target);
  }

  function onRemoveFrame() {
    // XXX Stop any scrolling
    // XXX Send event to application so it can put up a prompt for deleting the
    // frame???
    // XXX In the future we should move this frame to the end, dim it, add
    // a return icon (i.e. undo), append the frame with its index. On click it
    // would be restored. On creating a new frame, it would be lost forever.
  }

  function removeFrame() {
    // XXX Remove hit test item so we don't get double-selection?
    // XXX Animate disappearance
    // XXX If we are down to zero frames, call addFrame again
  }

  function selectFrame() {
    // XXX Scroll? If we're not scrolling already and it's offscreen, then yes
    // XXX Dispatch frameChanged event with index of frame
    // XXX Mark the frame as selected
  }

  function init() {
    // XXX Register handler for plus button
    // XXX Register for touch handling
    addFrame();
  }
  init();
 ]]>
 </script>
</svg>
